# 미션 - 레이싱 경주 🏁

## 🛠️ 객체지향 설계
- 협력, 역할, 책임에 집중한다.
- 객체의 행위에 중심을 두고, 협력 관계를 생각한다.
- 행위의 결과는 상태에 의존적이다.

## 📦 도메인(racingcar) 모델
- 사용자
- 게임 컨트롤러(입력 버튼)
- 게임 컨트롤러(출력 화면)
- 자동차

## ✅ 기능 목록

### 1. 게임 시작
- [ ] 사용자는 경주 할 자동차 이름 입력
  - [ ] 이름은 쉼표(,) 기준으로 구분
  - [ ] 이름은 5자 이하만 가능
- [ ] 사용자는 자동차가 이동할 회수 입력

### 2. 게임 진행
- [ ] 자동차는 0~9 사이의 무작위 값을 구한 후 4 이상일 경우 전진
  - [ ] 매 회수 별 실행 결과를 출력

### 3. 게임 종료
- [ ] 최종 우승자 출력
  - [ ] 우승자는 한 명 이상일 수 있음
  - [ ] 여러 명일 경우 쉼표(,)를 이용하여 구분
### 4. 예외 처리
- 사용자가 잘못된 값을 입력할 경우 `IllegalArgumentException`을 발생시킨 후 애플리케이션은 종료되어야 한다.

### 5. 제출 전 점검 리스트
- [ ] 요구사항을 정확히 준수
  - [ ] indent(인덴트, 들여쓰기) depth를 3이 넘지 않도록 구현한다. 2까지만 허용한다.
  - [ ] 3항 연산자를 쓰지 않는다.
  - [ ] 함수(또는 메서드)가 한 가지 일만 하도록 최대한 작게 만들어라.
  - [ ] JUnit 5와 AssertJ를 이용하여 본인이 정리한 기능 목록이 정상 동작함을 테스트 코드로 확인한다.
- [ ] 커밋 메시지를 의미 있게 작성
- [ ] git을 통해 관리할 자원 고려
- [ ] 이름을 통해 의도 드러내며 축약하지 않기
- [ ] Java에서 제공하는 API를 적극 활용
- [ ] 배열 대신 Java Collection을 사용
- [ ] 비즈니스 로직과 UI 로직을 분리
- [ ] README 상세히 작성
- [ ] 기능 목록 재검토, 업데이트
- [ ] 값을 하드 코딩하지 말기
- [ ] 한 함수가 한 가지 기능만 담당
- [ ] 테스트 작성 이유 정리
- [ ] 연관성이 있는 상수는 static final 대신 enum을 활용
- [ ] final 키워드를 사용해 값의 변경 막기
- [ ] 객체는 객체스럽게 사용
- [ ] 필드(인스턴스 변수)의 수를 줄이기 위해 노력
- [ ] 성공 케이스, 예외 케이스 테스트